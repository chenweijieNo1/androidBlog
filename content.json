{"meta":{"title":"androidBlog","subtitle":null,"description":null,"author":"Ericchen","url":"https://chenweijieno1.github.io/androidBlog"},"pages":[{"title":"ericchen的个人博客","date":"2017-10-27T09:25:24.000Z","updated":"2017-11-13T08:17:56.077Z","comments":true,"path":"about/index.html","permalink":"https://chenweijieno1.github.io/androidBlog/about/index.html","excerpt":"","text":"Hello，I’m ericchen！一名Android工程师，欢迎大家访问我的博客，很高兴认识大家！ 最后，该折腾就折腾！好记性不如烂笔头！！！"},{"title":"categories","date":"2017-10-27T09:26:48.000Z","updated":"2017-10-27T09:27:35.582Z","comments":true,"path":"categories/index.html","permalink":"https://chenweijieno1.github.io/androidBlog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-27T09:11:41.000Z","updated":"2017-10-27T09:13:34.226Z","comments":true,"path":"tags/index.html","permalink":"https://chenweijieno1.github.io/androidBlog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ViewPager使用详解","slug":"ViewPager使用详解","date":"2017-12-21T06:11:00.000Z","updated":"2017-12-26T07:59:18.325Z","comments":true,"path":"2017/12/21/ViewPager使用详解/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/12/21/ViewPager使用详解/","excerpt":"前言在开发中ViewPager是不可或缺的控件，引导页、轮播图、卡片画廊等效果大多数是用ViewPager来实现，该文章主要是梳理下ViewPager的用法。主要包括以下内容： ViewPager的简介与作用 ViewPager的适配器 自定义ViewPager的切换效果 ViewPager的基础使用 ViewPager结合第三方库实现小圆点指示器效果 ViewPager结合design库实现tab切换 基于ViewPager实现广告轮播控件 1、ViewPager的简介与作用ViewPager是android扩展包v4包中的类，继承自ViewGroup，它是一个容器类，可以添加其他的view，实现多个view左右切换、滑动，这个控件大家使用比较多，也比较熟悉了，下面说下常用的几个方法： setAdapter(PagerAdapter adapter) 设置适配器 setOffscreenPageLimit(int limit) 设置缓存的页面个数，默认是1个 setCurrentItem(int item) 跳转到某个页面 setOnPageChangeListener(…) 设置页面滑动时的监听器 setPageTransformer(…) 设置页面切换时的动画效果 setPageMargin(int margin) 设置不同页面之间的间隔 2、ViewPager的适配器ViewPager需要设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是个基类，我们经常使用它的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter，先说说它们之间的使用区别吧。","text":"前言在开发中ViewPager是不可或缺的控件，引导页、轮播图、卡片画廊等效果大多数是用ViewPager来实现，该文章主要是梳理下ViewPager的用法。主要包括以下内容： ViewPager的简介与作用 ViewPager的适配器 自定义ViewPager的切换效果 ViewPager的基础使用 ViewPager结合第三方库实现小圆点指示器效果 ViewPager结合design库实现tab切换 基于ViewPager实现广告轮播控件 1、ViewPager的简介与作用ViewPager是android扩展包v4包中的类，继承自ViewGroup，它是一个容器类，可以添加其他的view，实现多个view左右切换、滑动，这个控件大家使用比较多，也比较熟悉了，下面说下常用的几个方法： setAdapter(PagerAdapter adapter) 设置适配器 setOffscreenPageLimit(int limit) 设置缓存的页面个数，默认是1个 setCurrentItem(int item) 跳转到某个页面 setOnPageChangeListener(…) 设置页面滑动时的监听器 setPageTransformer(…) 设置页面切换时的动画效果 setPageMargin(int margin) 设置不同页面之间的间隔 2、ViewPager的适配器ViewPager需要设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是个基类，我们经常使用它的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter，先说说它们之间的使用区别吧。PagerAdapter是个抽象的适配器，如果继承自该类，至少需要实现 instantiateItem(), destroyItem(), getCount() 以及 isViewFromObject()。12345678910111213141516171819202122232425262728public class AdapterViewpager extends PagerAdapter &#123; private List&lt;View&gt; mViewList; public AdapterViewpager(List&lt;View&gt; mViewList) &#123; this.mViewList = mViewList; &#125; @Override public int getCount() &#123;//必须实现 数据个数 return mViewList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123;//必须实现 这个方法用于判断是否由对象生成界面 return view == object; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123;//必须实现，实例化 要显示的页面或需要缓存的页面，进行布局的初始化 container.addView(mViewList.get(position)); return mViewList.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123;//必须实现，销毁 container.removeView(mViewList.get(position)); &#125;&#125; FragmentPagerAdapter和FragmentStatePagerAdapter更专注于每一项是fragment的情况，FragmentPagerAdpater将每一个页面表示为一个fragment，并且每一个fragment都将会保存到FragmentManger当中，当用户没可能再次回到页面的时候，FragmentManager才会将这个fragment销毁，对于不再需要的fragment，选择调用onDetach()方法，仅销毁视图，但不会销毁fragment实例；FragmentStatePagerAdapter会销毁不再需要的fragment，当当前事务提交以后，会彻底的将fragment从当前activity的FragmentManger中移除，销毁时会将其onSaveInstance(Bundle outState)中Bundle保存下来，当用户切换回来，可以通过该bundle恢复生成新的fragment.总的来说，FragmentStatePagerAdapter更省内存，但花时间，一般情况下，如果只有3、4个tab，可以选择FragmentPagerAdapter；如果展示数量特别多的条目，可以考虑FragmentStatePagerAdapter. 两者的实现方式一样，如下所示： 1234567891011121314151617181920212223public class AdapterFragment extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; mFragments; public AdapterFragment(FragmentManager fm, List&lt;Fragment&gt; mFragments) &#123; super(fm); this.mFragments = mFragments; &#125; @Override public Fragment getItem(int position) &#123;//必须实现 return mFragments.get(position); &#125; @Override public int getCount() &#123;//必须实现 return mFragments.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123;//选择性实现 return mFragments.get(position).getClass().getSimpleName(); &#125;&#125; 3、自定义ViewPager的切换效果官方提供了一个内部接口ViewPager.PageTransformer来供我们实现自定义切换动效，这个接口只提供一个方法：public void transformPage(View view,float position) transformPage有两个参数，一个是view，当前要设置动效的页面，这个页面不单单是当前显示的页面，即将滑出的页面，即将滑入的页面，已经隐藏的页面，但如何分辨View指哪个页面呢？这就需要第二个参数position来辨别。 从doc注释来看，当前选中的item的position为0，被选中item的前一个为-1，后一个为1，这前提是没有设置pageMargin，如果设置了pageMargin，前后item的position需要分别加上或减去（前减后加）一个偏移量（pageMargin / pageWidth） 滑动界面时postion是动态变化的，假设有三个页面view1，view2，view3从左至右在viewPager中显示： 往左滑动时：view1，view2，view3的position都是不断变小的。view1的position: 0 → -1 → 负无穷大view2的position: 1 → 0 → -1view3的position: 1 → 0 往右滑动时：view1，view2，view3的position都是不断变大的。view1的position: -1 → 0view2的position: -1 → 0 → 1view3的position: 0 → 1→ 正无穷大 当position是正负无穷大时view就离开屏幕视野了。因此最核心的控制逻辑是在[-1,0]和(0,1]这两个区间，通过设置透明度，平移，旋转，缩放等动画组合可以实现各式各样的页面变化效果。 1234567891011121314151617181920212223242526272829303132333435363738394041public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; @SuppressLint(&quot;NewApi&quot;) public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 4、ViewPager的简单使用 布局文件声明控件 12345&lt;!--填充整个页面的ViewPager--&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 代码中设置数据 123ViewPager viewPager = (ViewPager) findViewById(R.id.viewpager);自定义类实现PagerAdapter，填充显示数据viewPager.setAdapter(new MyAdapter()); 5、ViewPager结合第三方库实现小圆点指示器效果https://github.com/ongakuer/CircleIndicator 6、ViewPager结合design库实现tab切换http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0731/3247.html 7、基于ViewPager实现广告轮播控件https://github.com/daimajia/AndroidImageSlider","categories":[{"name":"android控件使用","slug":"android控件使用","permalink":"https://chenweijieno1.github.io/androidBlog/categories/android控件使用/"}],"tags":[{"name":"android控件使用","slug":"android控件使用","permalink":"https://chenweijieno1.github.io/androidBlog/tags/android控件使用/"}]},{"title":"Android常用工具栏","slug":"Android常用工具类","date":"2017-12-19T06:36:00.000Z","updated":"2017-12-22T06:12:39.078Z","comments":true,"path":"2017/12/19/Android常用工具类/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/12/19/Android常用工具类/","excerpt":"1、日志工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import android.util.Log; /** * Log统一管理类 * */ public class LogUtils &#123; private LogUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException(&quot;cannot be instantiated&quot;); &#125; public static boolean isDebug = true;// 是否需要打印bug，可以在application的onCreate函数里面初始化 private static final String TAG = &quot;LogUtil&quot;; // 下面四个是默认tag的函数 public static void i(String msg) &#123; if (isDebug) Log.i(TAG, msg); &#125; public static void d(String msg) &#123; if (isDebug) Log.d(TAG, msg); &#125; public static void e(String msg) &#123; if (isDebug) Log.e(TAG, msg); &#125; public static void v(String msg) &#123; if (isDebug) Log.v(TAG, msg); &#125; // 下面是传入自定义tag的函数 public static void i(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; public static void d(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; public static void e(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; public static void v(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; &#125; 2、Toast管理类","text":"1、日志工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import android.util.Log; /** * Log统一管理类 * */ public class LogUtils &#123; private LogUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException(&quot;cannot be instantiated&quot;); &#125; public static boolean isDebug = true;// 是否需要打印bug，可以在application的onCreate函数里面初始化 private static final String TAG = &quot;LogUtil&quot;; // 下面四个是默认tag的函数 public static void i(String msg) &#123; if (isDebug) Log.i(TAG, msg); &#125; public static void d(String msg) &#123; if (isDebug) Log.d(TAG, msg); &#125; public static void e(String msg) &#123; if (isDebug) Log.e(TAG, msg); &#125; public static void v(String msg) &#123; if (isDebug) Log.v(TAG, msg); &#125; // 下面是传入自定义tag的函数 public static void i(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; public static void d(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; public static void e(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; public static void v(String tag, String msg) &#123; if (isDebug) Log.i(tag, msg); &#125; &#125; 2、Toast管理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import android.content.Context; import android.widget.Toast; /** * Toast统一管理类 * */ public class ToastUtils &#123; private ToastUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException(&quot;cannot be instantiated&quot;); &#125; public static boolean isShow = true; /** * 短时间显示Toast * * @param context * @param message */ public static void showShort(Context context, CharSequence message) &#123; if (isShow) Toast.makeText(context, message, Toast.LENGTH_SHORT).show(); &#125; /** * 短时间显示Toast * * @param context * @param message */ public static void showShort(Context context, int message) &#123; if (isShow) Toast.makeText(context, message, Toast.LENGTH_SHORT).show(); &#125; /** * 长时间显示Toast * * @param context * @param message */ public static void showLong(Context context, CharSequence message) &#123; if (isShow) Toast.makeText(context, message, Toast.LENGTH_LONG).show(); &#125; /** * 长时间显示Toast * * @param context * @param message */ public static void showLong(Context context, int message) &#123; if (isShow) Toast.makeText(context, message, Toast.LENGTH_LONG).show(); &#125; /** * 自定义显示Toast时间 * * @param context * @param message * @param duration */ public static void show(Context context, CharSequence message, int duration) &#123; if (isShow) Toast.makeText(context, message, duration).show(); &#125; /** * 自定义显示Toast时间 * * @param context * @param message * @param duration */ public static void show(Context context, int message, int duration) &#123; if (isShow) Toast.makeText(context, message, duration).show(); &#125; &#125; 3、SharedPreferences封装类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Map; import android.content.Context; import android.content.SharedPreferences; public class SPUtils &#123; /** * 保存在手机里面的文件名 */ public static final String FILE_NAME = &quot;share_data&quot;; /** * 保存数据的方法，我们需要拿到保存数据的具体类型，然后根据类型调用不同的保存方法 * * @param context * @param key * @param object */ public static void put(Context context, String key, Object object) &#123; SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); if (object instanceof String) &#123; editor.putString(key, (String) object); &#125; else if (object instanceof Integer) &#123; editor.putInt(key, (Integer) object); &#125; else if (object instanceof Boolean) &#123; editor.putBoolean(key, (Boolean) object); &#125; else if (object instanceof Float) &#123; editor.putFloat(key, (Float) object); &#125; else if (object instanceof Long) &#123; editor.putLong(key, (Long) object); &#125; else &#123; editor.putString(key, object.toString()); &#125; SharedPreferencesCompat.apply(editor); &#125; /** * 得到保存数据的方法，我们根据默认值得到保存的数据的具体类型，然后调用相对于的方法获取值 * * @param context * @param key * @param defaultObject * @return */ public static Object get(Context context, String key, Object defaultObject) &#123; SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE); if (defaultObject instanceof String) &#123; return sp.getString(key, (String) defaultObject); &#125; else if (defaultObject instanceof Integer) &#123; return sp.getInt(key, (Integer) defaultObject); &#125; else if (defaultObject instanceof Boolean) &#123; return sp.getBoolean(key, (Boolean) defaultObject); &#125; else if (defaultObject instanceof Float) &#123; return sp.getFloat(key, (Float) defaultObject); &#125; else if (defaultObject instanceof Long) &#123; return sp.getLong(key, (Long) defaultObject); &#125; return null; &#125; /** * 移除某个key值已经对应的值 * @param context * @param key */ public static void remove(Context context, String key) &#123; SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.remove(key); SharedPreferencesCompat.apply(editor); &#125; /** * 清除所有数据 * @param context */ public static void clear(Context context) &#123; SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.clear(); SharedPreferencesCompat.apply(editor); &#125; /** * 查询某个key是否已经存在 * @param context * @param key * @return */ public static boolean contains(Context context, String key) &#123; SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE); return sp.contains(key); &#125; /** * 返回所有的键值对 * * @param context * @return */ public static Map&lt;String, ?&gt; getAll(Context context) &#123; SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE); return sp.getAll(); &#125; /** * 创建一个解决SharedPreferencesCompat.apply方法的一个兼容类 * * @author zhy * */ private static class SharedPreferencesCompat &#123; private static final Method sApplyMethod = findApplyMethod(); /** * 反射查找apply的方法 * * @return */ @SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) private static Method findApplyMethod() &#123; try &#123; Class clz = SharedPreferences.Editor.class; return clz.getMethod(&quot;apply&quot;); &#125; catch (NoSuchMethodException e) &#123; &#125; return null; &#125; /** * 如果找到则使用apply执行，否则使用commit * * @param editor */ public static void apply(SharedPreferences.Editor editor) &#123; try &#123; if (sApplyMethod != null) &#123; sApplyMethod.invoke(editor); return; &#125; &#125; catch (IllegalArgumentException e) &#123; &#125; catch (IllegalAccessException e) &#123; &#125; catch (InvocationTargetException e) &#123; &#125; editor.commit(); &#125; &#125; &#125; 注意一点，里面所有的commit操作使用了SharedPreferencesCompat.apply进行了替代，目的是尽可能的使用apply代替commit 首先说下为什么，因为commit方法是同步的，并且我们很多时候的commit操作都是UI线程中，毕竟是IO操作，尽可能异步； 所以我们使用apply进行替代，apply异步的进行写入； 但是apply相当于commit来说是new API呢，为了更好的兼容，我们做了适配； 4、单位转换类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import android.content.Context; import android.util.TypedValue; /** * 常用单位转换的辅助类 * * * */ public class DensityUtils &#123; private DensityUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException(&quot;cannot be instantiated&quot;); &#125; /** * dp转px * * @param context * @param val * @return */ public static int dp2px(Context context, float dpVal) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpVal, context.getResources().getDisplayMetrics()); &#125; /** * sp转px * * @param context * @param val * @return */ public static int sp2px(Context context, float spVal) &#123; return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, spVal, context.getResources().getDisplayMetrics()); &#125; /** * px转dp * * @param context * @param pxVal * @return */ public static float px2dp(Context context, float pxVal) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (pxVal / scale); &#125; /** * px转sp * * @param fontScale * @param pxVal * @return */ public static float px2sp(Context context, float pxVal) &#123; return (pxVal / context.getResources().getDisplayMetrics().scaledDensity); &#125; &#125; 5、SD卡相关辅助类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.io.File; import android.os.Environment; import android.os.StatFs; /** * SD卡相关的辅助类 * * * */ public class SDCardUtils &#123; private SDCardUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException(&quot;cannot be instantiated&quot;); &#125; /** * 判断SDCard是否可用 * * @return */ public static boolean isSDCardEnable() &#123; return Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED); &#125; /** * 获取SD卡路径 * * @return */ public static String getSDCardPath() &#123; return Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator; &#125; /** * 获取SD卡的剩余容量 单位byte * * @return */ public static long getSDCardAllSize() &#123; if (isSDCardEnable()) &#123; StatFs stat = new StatFs(getSDCardPath()); // 获取空闲的数据块的数量 long availableBlocks = (long) stat.getAvailableBlocks() - 4; // 获取单个数据块的大小（byte） long freeBlocks = stat.getAvailableBlocks(); return freeBlocks * availableBlocks; &#125; return 0; &#125; /** * 获取指定路径所在空间的剩余可用容量字节数，单位byte * * @param filePath * @return 容量字节 SDCard可用空间，内部存储可用空间 */ public static long getFreeBytes(String filePath) &#123; // 如果是sd卡的下的路径，则获取sd卡可用容量 if (filePath.startsWith(getSDCardPath())) &#123; filePath = getSDCardPath(); &#125; else &#123;// 如果是内部存储的路径，则获取内存存储的可用容量 filePath = Environment.getDataDirectory().getAbsolutePath(); &#125; StatFs stat = new StatFs(filePath); long availableBlocks = (long) stat.getAvailableBlocks() - 4; return stat.getBlockSize() * availableBlocks; &#125; /** * 获取系统存储路径 * * @return */ public static String getRootDirectoryPath() &#123; return Environment.getRootDirectory().getAbsolutePath(); &#125; &#125; 6、屏幕相关辅助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import android.app.Activity; import android.content.Context; import android.graphics.Bitmap; import android.graphics.Rect; import android.util.DisplayMetrics; import android.view.View; import android.view.WindowManager; /** * 获得屏幕相关的辅助类 * * * */ public class ScreenUtils &#123; private ScreenUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException(&quot;cannot be instantiated&quot;); &#125; /** * 获得屏幕高度 * * @param context * @return */ public static int getScreenWidth(Context context) &#123; WindowManager wm = (WindowManager) context .getSystemService(Context.WINDOW_SERVICE); DisplayMetrics outMetrics = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(outMetrics); return outMetrics.widthPixels; &#125; /** * 获得屏幕宽度 * * @param context * @return */ public static int getScreenHeight(Context context) &#123; WindowManager wm = (WindowManager) context .getSystemService(Context.WINDOW_SERVICE); DisplayMetrics outMetrics = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(outMetrics); return outMetrics.heightPixels; &#125; /** * 获得状态栏的高度 * * @param context * @return */ public static int getStatusHeight(Context context) &#123; int statusHeight = -1; try &#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.android.internal.R$dimen&quot;); Object object = clazz.newInstance(); int height = Integer.parseInt(clazz.getField(&quot;status_bar_height&quot;) .get(object).toString()); statusHeight = context.getResources().getDimensionPixelSize(height); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return statusHeight; &#125; /** * 获取当前屏幕截图，包含状态栏 * * @param activity * @return */ public static Bitmap snapShotWithStatusBar(Activity activity) &#123; View view = activity.getWindow().getDecorView(); view.setDrawingCacheEnabled(true); view.buildDrawingCache(); Bitmap bmp = view.getDrawingCache(); int width = getScreenWidth(activity); int height = getScreenHeight(activity); Bitmap bp = null; bp = Bitmap.createBitmap(bmp, 0, 0, width, height); view.destroyDrawingCache(); return bp; &#125; /** * 获取当前屏幕截图，不包含状态栏 * * @param activity * @return */ public static Bitmap snapShotWithoutStatusBar(Activity activity) &#123; View view = activity.getWindow().getDecorView(); view.setDrawingCacheEnabled(true); view.buildDrawingCache(); Bitmap bmp = view.getDrawingCache(); Rect frame = new Rect(); activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame); int statusBarHeight = frame.top; int width = getScreenWidth(activity); int height = getScreenHeight(activity); Bitmap bp = null; bp = Bitmap.createBitmap(bmp, 0, statusBarHeight, width, height - statusBarHeight); view.destroyDrawingCache(); return bp; &#125; &#125; 7、App相关辅助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.PackageManager.NameNotFoundException; /** * 跟App相关的辅助类 * * * */ public class AppUtils &#123; private AppUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException(&quot;cannot be instantiated&quot;); &#125; /** * 获取应用程序名称 */ public static String getAppName(Context context) &#123; try &#123; PackageManager packageManager = context.getPackageManager(); PackageInfo packageInfo = packageManager.getPackageInfo( context.getPackageName(), 0); int labelRes = packageInfo.applicationInfo.labelRes; return context.getResources().getString(labelRes); &#125; catch (NameNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * [获取应用程序版本名称信息] * * @param context * @return 当前应用的版本名称 */ public static String getVersionName(Context context) &#123; try &#123; PackageManager packageManager = context.getPackageManager(); PackageInfo packageInfo = packageManager.getPackageInfo( context.getPackageName(), 0); return packageInfo.versionName; &#125; catch (NameNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 8、软键盘相关辅助类123456789101112131415161718192021222324252627282930313233343536373839404142434445import android.content.Context; import android.view.inputmethod.InputMethodManager; import android.widget.EditText; /** * 打开或关闭软键盘 * * @author zhy * */ public class KeyBoardUtils &#123; /** * 打卡软键盘 * * @param mEditText * 输入框 * @param mContext * 上下文 */ public static void openKeybord(EditText mEditText, Context mContext) &#123; InputMethodManager imm = (InputMethodManager) mContext .getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(mEditText, InputMethodManager.RESULT_SHOWN); imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY); &#125; /** * 关闭软键盘 * * @param mEditText * 输入框 * @param mContext * 上下文 */ public static void closeKeybord(EditText mEditText, Context mContext) &#123; InputMethodManager imm = (InputMethodManager) mContext .getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(mEditText.getWindowToken(), 0); &#125; &#125; 9、网络相关辅助类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import android.app.Activity; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.net.ConnectivityManager; import android.net.NetworkInfo; /** * 跟网络相关的工具类 * * * */ public class NetUtils &#123; private NetUtils() &#123; /* cannot be instantiated */ throw new UnsupportedOperationException(&quot;cannot be instantiated&quot;); &#125; /** * 判断网络是否连接 * * @param context * @return */ public static boolean isConnected(Context context) &#123; ConnectivityManager connectivity = (ConnectivityManager) context .getSystemService(Context.CONNECTIVITY_SERVICE); if (null != connectivity) &#123; NetworkInfo info = connectivity.getActiveNetworkInfo(); if (null != info &amp;&amp; info.isConnected()) &#123; if (info.getState() == NetworkInfo.State.CONNECTED) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * 判断是否是wifi连接 */ public static boolean isWifi(Context context) &#123; ConnectivityManager cm = (ConnectivityManager) context .getSystemService(Context.CONNECTIVITY_SERVICE); if (cm == null) return false; return cm.getActiveNetworkInfo().getType() == ConnectivityManager.TYPE_WIFI; &#125; /** * 打开网络设置界面 */ public static void openSetting(Activity activity) &#123; Intent intent = new Intent(&quot;/&quot;); ComponentName cm = new ComponentName(&quot;com.android.settings&quot;, &quot;com.android.settings.WirelessSettings&quot;); intent.setComponent(cm); intent.setAction(&quot;android.intent.action.VIEW&quot;); activity.startActivityForResult(intent, 0); &#125; &#125; 10、Http相关辅助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228import java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.HttpURLConnection; import java.net.URL; /** * Http请求的工具类 * * @author zhy * */ public class HttpUtils &#123; private static final int TIMEOUT_IN_MILLIONS = 5000; public interface CallBack &#123; void onRequestComplete(String result); &#125; /** * 异步的Get请求 * * @param urlStr * @param callBack */ public static void doGetAsyn(final String urlStr, final CallBack callBack) &#123; new Thread() &#123; public void run() &#123; try &#123; String result = doGet(urlStr); if (callBack != null) &#123; callBack.onRequestComplete(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;; &#125;.start(); &#125; /** * 异步的Post请求 * @param urlStr * @param params * @param callBack * @throws Exception */ public static void doPostAsyn(final String urlStr, final String params, final CallBack callBack) throws Exception &#123; new Thread() &#123; public void run() &#123; try &#123; String result = doPost(urlStr, params); if (callBack != null) &#123; callBack.onRequestComplete(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;; &#125;.start(); &#125; /** * Get请求，获得返回数据 * * @param urlStr * @return * @throws Exception */ public static String doGet(String urlStr) &#123; URL url = null; HttpURLConnection conn = null; InputStream is = null; ByteArrayOutputStream baos = null; try &#123; url = new URL(urlStr); conn = (HttpURLConnection) url.openConnection(); conn.setReadTimeout(TIMEOUT_IN_MILLIONS); conn.setConnectTimeout(TIMEOUT_IN_MILLIONS); conn.setRequestMethod(&quot;GET&quot;); conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); if (conn.getResponseCode() == 200) &#123; is = conn.getInputStream(); baos = new ByteArrayOutputStream(); int len = -1; byte[] buf = new byte[128]; while ((len = is.read(buf)) != -1) &#123; baos.write(buf, 0, len); &#125; baos.flush(); return baos.toString(); &#125; else &#123; throw new RuntimeException(&quot; responseCode is not 200 ... &quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (is != null) is.close(); &#125; catch (IOException e) &#123; &#125; try &#123; if (baos != null) baos.close(); &#125; catch (IOException e) &#123; &#125; conn.disconnect(); &#125; return null ; &#125; /** * 向指定 URL 发送POST方法的请求 * * @param url * 发送请求的 URL * @param param * 请求参数，请求参数应该是 name1=value1&amp;name2=value2 的形式。 * @return 所代表远程资源的响应结果 * @throws Exception */ public static String doPost(String url, String param) &#123; PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; try &#123; URL realUrl = new URL(url); // 打开和URL之间的连接 HttpURLConnection conn = (HttpURLConnection) realUrl .openConnection(); // 设置通用的请求属性 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestMethod(&quot;POST&quot;); conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); conn.setRequestProperty(&quot;charset&quot;, &quot;utf-8&quot;); conn.setUseCaches(false); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); conn.setReadTimeout(TIMEOUT_IN_MILLIONS); conn.setConnectTimeout(TIMEOUT_IN_MILLIONS); if (param != null &amp;&amp; !param.trim().equals(&quot;&quot;)) &#123; // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); &#125; // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 使用finally块来关闭输出流、输入流 finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; return result; &#125; &#125; 11、对话框工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * * 使用观察者模式来实现确定结果回调 * * 调用方式： * AlertDialogUtil dialogUtil = new AlertDialogUtil(context); * dialogUtil.showDialog(&quot;确定删除已上传的图片？&quot;); * dialogUtil.setDialogPositiveButtonListener(new AlertDialogUtil.DialogPositiveButtonListener() &#123; * * @Override * public void setDialogPositiveButtonListener() &#123; * * &#125; * &#125;); */public class AlertDialogUtil &#123; public Context context; private DialogPositiveButtonListener listener; public AlertDialogUtil(Context context) &#123; this.context = context; &#125; public void showDialog(String message) &#123; AlertDialog.Builder dialog = new AlertDialog.Builder(context); dialog.setMessage(message); dialog.setCancelable(false);//点击框外取消 dialog.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; if (listener != null) &#123; listener.setDialogPositiveButtonListener(); &#125; &#125; &#125;); dialog.setNegativeButton(&quot;取消&quot;, null); dialog.show(); &#125; public void setDialogPositiveButtonListener(DialogPositiveButtonListener listener) &#123; this.listener = listener; &#125; public interface DialogPositiveButtonListener &#123; void setDialogPositiveButtonListener(); &#125;&#125; 12、文件相关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class FileUtils &#123; public static String SDPATH = Environment.getExternalStorageDirectory() + &quot;/formats/&quot;;// 获取文件夹 // 保存图片 public static boolean saveBitmap(Bitmap mBitmap, String path, String imgName) &#123; String sdStatus = Environment.getExternalStorageState(); if (!sdStatus.equals(Environment.MEDIA_MOUNTED)) &#123; // 检测sd是否可用 return false; &#125; FileOutputStream b = null; File file = new File(path); file.mkdirs();// 创建文件夹 String fileName = path + imgName;// delFile(path, imgName);//删除本地旧图 try &#123; b = new FileOutputStream(fileName); mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, b);// 把数据写入文件 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; b.flush(); b.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; public static File createSDDir(String dirName) throws IOException &#123; File dir = new File(SDPATH + dirName); if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) &#123; System.out.println(&quot;createSDDir:&quot; + dir.getAbsolutePath()); System.out.println(&quot;createSDDir:&quot; + dir.mkdir()); &#125; return dir; &#125; public static boolean isFileExist(String fileName) &#123; File file = new File(SDPATH + fileName); file.isFile(); return file.exists(); &#125; // 删除文件 public static void delFile(String path, String fileName) &#123; File file = new File(path + fileName); if (file.isFile()) &#123; file.delete(); &#125; file.exists(); &#125; // 删除文件夹和文件夹里面的文件 public static void deleteDir() &#123; File dir = new File(SDPATH); if (dir == null || !dir.exists() || !dir.isDirectory()) return; for (File file : dir.listFiles()) &#123; if (file.isFile()) file.delete(); // 删除所有文件 else if (file.isDirectory()) deleteDir(); // 递规的方式删除文件夹 &#125; dir.delete();// 删除目录本身 &#125; public static boolean fileIsExists(String path) &#123; try &#123; File f = new File(path); if (!f.exists()) &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true; &#125;&#125; 13、时间戳相关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class DateUtils &#123; private static SimpleDateFormat sf; private static SimpleDateFormat sdf; /** * 获取系统时间 格式为：&quot;yyyy/MM/dd &quot; **/ public static String getCurrentDate() &#123; Date d = new Date(); sf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); return sf.format(d); &#125; /** * 获取系统时间 格式为：&quot;yyyy &quot; **/ public static String getCurrentYear() &#123; Date d = new Date(); sf = new SimpleDateFormat(&quot;yyyy&quot;); return sf.format(d); &#125; /** * 获取系统时间 格式为：&quot;MM&quot; **/ public static String getCurrentMonth() &#123; Date d = new Date(); sf = new SimpleDateFormat(&quot;MM&quot;); return sf.format(d); &#125; /** * 获取系统时间 格式为：&quot;dd&quot; **/ public static String getCurrentDay() &#123; Date d = new Date(); sf = new SimpleDateFormat(&quot;dd&quot;); return sf.format(d); &#125; /** * 获取当前时间戳 * * @return */ public static long getCurrentTime() &#123; long d = new Date().getTime() / 1000; return d; &#125; /** * 时间戳转换成字符窜 */ public static String getDateToString(long time) &#123; Date d = new Date(time * 1000); sf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); return sf.format(d); &#125; /** * 时间戳中获取年 */ public static String getYearFromTime(long time) &#123; Date d = new Date(time * 1000); sf = new SimpleDateFormat(&quot;yyyy&quot;); return sf.format(d); &#125; /** * 时间戳中获取月 */ public static String getMonthFromTime(long time) &#123; Date d = new Date(time * 1000); sf = new SimpleDateFormat(&quot;MM&quot;); return sf.format(d); &#125; /** * 时间戳中获取日 */ public static String getDayFromTime(long time) &#123; Date d = new Date(time * 1000); sf = new SimpleDateFormat(&quot;dd&quot;); return sf.format(d); &#125; /** * 将字符串转为时间戳 */ public static long getStringToDate(String time) &#123; sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); Date date = new Date(); try &#123; date = sdf.parse(time); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return date.getTime(); &#125;&#125; 14、比较常用的正则表达式验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class RegularUtils &#123; private RegularUtils() &#123; throw new UnsupportedOperationException(&quot;u can&apos;t fuck me...&quot;); &#125; /** * 验证手机号（简单） */ private static final String REGEX_MOBILE_SIMPLE = &quot;^[1]\\\\d&#123;10&#125;$&quot;; /** * 验证手机号（精确） * &lt;p&gt; * &lt;p&gt;移动：134(0-8)、135、136、137、138、139、147、150、151、152、157、158、159、178、182、183、184、187、188 * &lt;p&gt;联通：130、131、132、145、155、156、175、176、185、186 * &lt;p&gt;电信：133、153、173、177、180、181、189 * &lt;p&gt;全球星：1349 * &lt;p&gt;虚拟运营商：170 */ private static final String REGEX_MOBILE_EXACT = &quot;^((13[0-9])|(14[5,7])|(15[0-3,5-8])|(17[0,3,5-8])|(18[0-9])|(147))\\\\d&#123;8&#125;$&quot;; /** * 验证座机号,正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx/ */ private static final String REGEX_TEL = &quot;^0\\\\d&#123;2,3&#125;[- ]?\\\\d&#123;7,8&#125;&quot;; /** * 验证邮箱 */ private static final String REGEX_EMAIL = &quot;^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*$&quot;; /** * 验证url */ private static final String REGEX_URL = &quot;http(s)?://([\\\\w-]+\\\\.)+[\\\\w-]+(/[\\\\w-./?%&amp;=]*)?&quot;; /** * 验证汉字 */ private static final String REGEX_CHZ = &quot;^[\\\\u4e00-\\\\u9fa5]+$&quot;; /** * 验证用户名,取值范围为a-z,A-Z,0-9,&quot;_&quot;,汉字，不能以&quot;_&quot;结尾,用户名必须是6-20位 */ private static final String REGEX_USERNAME = &quot;^[\\\\w\\\\u4e00-\\\\u9fa5]&#123;6,20&#125;(?&lt;!_)$&quot;; /** * 验证IP地址 */ private static final String REGEX_IP = &quot;((2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)\\\\.)&#123;3&#125;(2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)&quot;; //If u want more please visit http://toutiao.com/i6231678548520731137/ /** * @param string 待验证文本 * @return 是否符合手机号（简单）格式 */ public static boolean isMobileSimple(String string) &#123; return isMatch(REGEX_MOBILE_SIMPLE, string); &#125; /** * @param string 待验证文本 * @return 是否符合手机号（精确）格式 */ public static boolean isMobileExact(String string) &#123; return isMatch(REGEX_MOBILE_EXACT, string); &#125; /** * @param string 待验证文本 * @return 是否符合座机号码格式 */ public static boolean isTel(String string) &#123; return isMatch(REGEX_TEL, string); &#125; /** * @param string 待验证文本 * @return 是否符合邮箱格式 */ public static boolean isEmail(String string) &#123; return isMatch(REGEX_EMAIL, string); &#125; /** * @param string 待验证文本 * @return 是否符合网址格式 */ public static boolean isURL(String string) &#123; return isMatch(REGEX_URL, string); &#125; /** * @param string 待验证文本 * @return 是否符合汉字 */ public static boolean isChz(String string) &#123; return isMatch(REGEX_CHZ, string); &#125; /** * @param string 待验证文本 * @return 是否符合用户名 */ public static boolean isUsername(String string) &#123; return isMatch(REGEX_USERNAME, string); &#125; /** * @param regex 正则表达式字符串 * @param string 要匹配的字符串 * @return 如果str 符合 regex的正则表达式格式,返回true, 否则返回 false; */ public static boolean isMatch(String regex, String string) &#123; return !TextUtils.isEmpty(string) &amp;&amp; Pattern.matches(regex, string); &#125;&#125;","categories":[{"name":"android工具","slug":"android工具","permalink":"https://chenweijieno1.github.io/androidBlog/categories/android工具/"}],"tags":[{"name":"android工具","slug":"android工具","permalink":"https://chenweijieno1.github.io/androidBlog/tags/android工具/"}]},{"title":"Android界面性能调优手册","slug":"Android界面性能调优手册","date":"2017-12-19T03:31:00.000Z","updated":"2017-12-19T03:32:52.389Z","comments":true,"path":"2017/12/19/Android界面性能调优手册/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/12/19/Android界面性能调优手册/","excerpt":"","text":"这里转载一篇好文分享给各位看看~~ Android界面性能调优手册","categories":[{"name":"android优化","slug":"android优化","permalink":"https://chenweijieno1.github.io/androidBlog/categories/android优化/"}],"tags":[{"name":"android优化","slug":"android优化","permalink":"https://chenweijieno1.github.io/androidBlog/tags/android优化/"}]},{"title":"WebViewStudy","slug":"WebViewStudy","date":"2017-12-18T03:45:00.000Z","updated":"2017-12-18T03:49:27.206Z","comments":true,"path":"2017/12/18/WebViewStudy/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/12/18/WebViewStudy/","excerpt":"","text":"WebView 全方面的使用，JS交互、进度条、发短信、打电话、发邮件、上传图片、字体设置、视频全屏播放等WebView使用Demo","categories":[{"name":"android常用知识","slug":"android常用知识","permalink":"https://chenweijieno1.github.io/androidBlog/categories/android常用知识/"}],"tags":[{"name":"android常用知识","slug":"android常用知识","permalink":"https://chenweijieno1.github.io/androidBlog/tags/android常用知识/"}]},{"title":"android解决输入法键盘遮盖布局问题","slug":"android解决输入法键盘遮盖布局问题","date":"2017-12-15T07:12:55.000Z","updated":"2017-12-15T07:16:15.306Z","comments":true,"path":"2017/12/15/android解决输入法键盘遮盖布局问题/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/12/15/android解决输入法键盘遮盖布局问题/","excerpt":"","text":"代码如下所示： 1234567891011121314151617181920212223242526272829303132333435/** * addLayoutListener方法如下 * @param main 根布局 * @param scroll 需要显示的最下方View */public void addLayoutListener(final View main, final View scroll) &#123; main.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect rect = new Rect(); //1、获取main在窗体的可视区域 main.getWindowVisibleDisplayFrame(rect); //2、获取main在窗体的不可视区域高度，在键盘没有弹起时，main.getRootView().getHeight()调节度应该和rect.bottom高度一样 int mainInvisibleHeight = main.getRootView().getHeight() - rect.bottom; int screenHeight = main.getRootView().getHeight();//屏幕高度 RelativeLayout scrollView = (RelativeLayout) main.findViewById(R.id.input_panel); //3、不可见区域大于屏幕本身高度的1/4：说明键盘弹起了 if (mainInvisibleHeight &gt; screenHeight / 4) &#123; int[] location = new int[2]; scroll.getLocationInWindow(location); // 4、获取Scroll的窗体坐标，算出main需要滚动的高度 int srollHeight = (location[1] + scroll.getHeight()) - rect.bottom; //5、让界面整体上移键盘的高度 if (viewScrollReset) &#123; scrollView.scrollTo(0, srollHeight + 10); viewScrollReset = false; &#125; &#125; else &#123; //3、不可见区域小于屏幕高度1/4时,说明键盘隐藏了，把界面下移，移回到原有高度 scrollView.scrollTo(0, 0); viewScrollReset = true; &#125; &#125; &#125;); &#125;","categories":[{"name":"android常见问题","slug":"android常见问题","permalink":"https://chenweijieno1.github.io/androidBlog/categories/android常见问题/"}],"tags":[{"name":"android常见问题","slug":"android常见问题","permalink":"https://chenweijieno1.github.io/androidBlog/tags/android常见问题/"}]},{"title":"Markdown的常用语法","slug":"Markdown的常用语法","date":"2017-12-15T06:17:11.000Z","updated":"2017-12-15T06:53:44.409Z","comments":true,"path":"2017/12/15/Markdown的常用语法/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/12/15/Markdown的常用语法/","excerpt":"注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上至少1个空格才有效！ 标题在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 列表支持有序列表和无序列表 无序列表使用-、+和*作为列表标记 有序列表则使用数字加英文句点.来表示","text":"注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上至少1个空格才有效！ 标题在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 列表支持有序列表和无序列表 无序列表使用-、+和*作为列表标记 有序列表则使用数字加英文句点.来表示 引用引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。 12345678910111213141516171819&gt; 这是一段引用 //在`&gt;`后面有 1 个空格&gt; &gt; 这是引用的代码块形式 //在`&gt;`后面有 5 个空格&gt; &gt; 代码例子：&gt; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&gt; 一级引用&gt; &gt; 二级引用&gt; &gt; &gt; 三级引用&gt; #### 这是一个四级标题&gt; &gt; 1. 这是第一行列表项&gt; 2. 这是第二行列表项 强调 两个或-代表加粗，一个或-代表斜体，代表删除 图片与链接图片与链接的语法很像，区别在一个 ! 号。二者格式： 12图片：![]() ![图片文本(可忽略)](图片地址)链接：[]() [链接文本](链接地址) 代码代码分为行内代码和代码块。 行内代码使用 代码 标识，可嵌入文字中 代码块使用4个空格或```标识 代码语法高亮在 ```后面加上空格和语言名称即可 表格表格对齐格式： 居左：:—-居中：:—-:或—–居右：—-: 例子： 标题 标题 标题 居左测试文本 居中测试文本 居右测试文本 居左测试文本1 居中测试文本2 居右测试文本3 居左测试文本11 居中测试文本22 居右测试文本33 居左测试文本111 居中测试文本222 居右测试文本333 分隔线一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。 换行在行尾添加两个空格加回车表示换行 参考自：Markdown的常用语法(个人总结)","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://chenweijieno1.github.io/androidBlog/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://chenweijieno1.github.io/androidBlog/tags/Markdown/"}]},{"title":"Hexo发布博客引用自带图片的方法","slug":"Hexo发布博客引用自带图片的方法","date":"2017-12-15T02:34:32.000Z","updated":"2017-12-15T02:48:10.358Z","comments":true,"path":"2017/12/15/Hexo发布博客引用自带图片的方法/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/12/15/Hexo发布博客引用自带图片的方法/","excerpt":"有两种方法，第一种是不用插件的情况，第二种是使用一种hexo的插件。无论哪种方法都有一个共同的前提：修改_config.yml配置文件post_asset_folder项为true。 创建博客必须使用命令创建：123hexo new [layout] &lt;title&gt;其中的layout项可以省略，例如：hexo new &quot;这是一个新的博客&quot; 使用完命令之后，在source/_post文件夹里面就会出现一个“这是一个新的博客.md”的文件和一个“这是一个新的博客”的文件夹。下一步就是把需要的图片放到新创建的那个文件夹里面去。 最后有两种方式来引用图片：","text":"有两种方法，第一种是不用插件的情况，第二种是使用一种hexo的插件。无论哪种方法都有一个共同的前提：修改_config.yml配置文件post_asset_folder项为true。 创建博客必须使用命令创建：123hexo new [layout] &lt;title&gt;其中的layout项可以省略，例如：hexo new &quot;这是一个新的博客&quot; 使用完命令之后，在source/_post文件夹里面就会出现一个“这是一个新的博客.md”的文件和一个“这是一个新的博客”的文件夹。下一步就是把需要的图片放到新创建的那个文件夹里面去。 最后有两种方式来引用图片： 第一种方法：1&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125; 用此种方法，而不是以前的方法，前提是你的hexo的版本是hexo3以上，到package.json里面看一下吧。如果不是hexo3以上的版本，那就只能用第二种方法了：hexo插件的方法 插件的链接 安装：npm install hexo-asset-image –save 之后就可以按照正常的方法使用的，比如：1我现在写了一个段落，并且想在这个段落的某一个地方[图片上传失败...(image-43fc5f-1510018038370)]引入一张图片 1我现在写了一个段落，并且想在这个段落的某一个地方[图片上传失败...(image-f9b1fb-1510018038370)]引入一张图片 此两种方法除了操作有些区别之外，在图片的显示上也略有不同，第一种的图片信息是会显示出来的，而第二种中括号里面的信息是不会显示的。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenweijieno1.github.io/androidBlog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenweijieno1.github.io/androidBlog/tags/Hexo/"}]},{"title":"Android Studio Git .gitignore操作","slug":"Android-Studio-Git-gitignore操作","date":"2017-12-15T02:26:36.000Z","updated":"2017-12-15T02:31:17.775Z","comments":true,"path":"2017/12/15/Android-Studio-Git-gitignore操作/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/12/15/Android-Studio-Git-gitignore操作/","excerpt":"在push项目到GitHub的时候，忽略这些文件需要做的步骤如下： 1.在项目目录下找到.gitignore文件（一般有两个地方存在该文件：一是根目录下，一是app目录下），如果没有找到该文件就创建一个 。该文件主要写明需要忽略的文件。 2.对于Android项目来说，有一个标准的需要忽略的文件（当然，也可以根据自己的项目而定），在GitHub上去下载Android.gitignore文件。下面为Android.gitignore文件的内容：123456789101112131415161718192021222324252627282930313233343536373839&lt;span style=&quot;font-size:14px;&quot;&gt;# Built application files*.apk*.ap_# Files for the Dalvik VM*.dex# Java class files*.class# Generated filesbin/gen/out/# Gradle files.gradle/build/# Local configuration file (sdk path, etc)local.properties# Proguard folder generated by Eclipseproguard/# Log Files*.log# Android Studio Navigation editor temp files.navigation/# Android Studio captures foldercaptures/# Intellij*.iml# Keystore files*.jks&lt;/span&gt;","text":"在push项目到GitHub的时候，忽略这些文件需要做的步骤如下： 1.在项目目录下找到.gitignore文件（一般有两个地方存在该文件：一是根目录下，一是app目录下），如果没有找到该文件就创建一个 。该文件主要写明需要忽略的文件。 2.对于Android项目来说，有一个标准的需要忽略的文件（当然，也可以根据自己的项目而定），在GitHub上去下载Android.gitignore文件。下面为Android.gitignore文件的内容：123456789101112131415161718192021222324252627282930313233343536373839&lt;span style=&quot;font-size:14px;&quot;&gt;# Built application files*.apk*.ap_# Files for the Dalvik VM*.dex# Java class files*.class# Generated filesbin/gen/out/# Gradle files.gradle/build/# Local configuration file (sdk path, etc)local.properties# Proguard folder generated by Eclipseproguard/# Log Files*.log# Android Studio Navigation editor temp files.navigation/# Android Studio captures foldercaptures/# Intellij*.iml# Keystore files*.jks&lt;/span&gt; 它主要的写法规则为：”#”表示注释，”*”表示通配符，可多个，”/“表示目录，”!”表示不忽略匹配到的文件或目录，”?”表示通配单个字符，”[]”表示包含单个字符的匹配列表。 3.git命令操作 接下来只需git add. ，git commit -m “comment” ，git push就行了（注意在app目录下也有需要忽略的文件）。这样上传到GitHub上的项目就忽略了不需要进行版本控制的文件。另外，从GitHub上Download下来的这个项目，在导入Android Studio中时，应该使用Import Project。","categories":[{"name":"git","slug":"git","permalink":"https://chenweijieno1.github.io/androidBlog/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chenweijieno1.github.io/androidBlog/tags/git/"}]},{"title":"git操作命令集合","slug":"git操作命令","date":"2017-10-30T02:01:52.674Z","updated":"2017-12-18T02:14:24.745Z","comments":true,"path":"2017/10/30/git操作命令/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/10/30/git操作命令/","excerpt":"常用命令克隆# git clone 仓库地址克隆指定分支# git clone -b 分支名 仓库地址切换到某个分支# git branch 分支名把修改文件添加到本地暂存区# git add .合并到当前分支# git merge 分支名提交修改文件# git commit -m “修改内容”更新# git pull提交到远程分支# git push origin 分支名","text":"常用命令克隆# git clone 仓库地址克隆指定分支# git clone -b 分支名 仓库地址切换到某个分支# git branch 分支名把修改文件添加到本地暂存区# git add .合并到当前分支# git merge 分支名提交修改文件# git commit -m “修改内容”更新# git pull提交到远程分支# git push origin 分支名","categories":[{"name":"git","slug":"git","permalink":"https://chenweijieno1.github.io/androidBlog/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://chenweijieno1.github.io/androidBlog/tags/git/"}]},{"title":"Hexo+Github搭建属于自己的博客","slug":"hexo使用攻略","date":"2017-10-25T16:00:00.000Z","updated":"2017-10-27T08:51:42.240Z","comments":true,"path":"2017/10/26/hexo使用攻略/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/10/26/hexo使用攻略/","excerpt":"前言平时我们会写写文章，偶尔看到一些精彩的东西会做点记录，但是会经常乱放，要用到时找起来麻烦，有时会忘记放在哪了，所以想着搭建一个博客来记录这些东西，现在大家使用Hexo比较多，因此该文章主要介绍如何搭建Hexo，以及搭建过程中出现的一些问题，最后列出一些常用的命令. http://www.cnblogs.com/visugar/p/6821777.html 常见问题：http://blog.csdn.net/nathan1987_/article/details/50322493 使用命令：http://www.jianshu.com/p/3a8dba06856a","text":"前言平时我们会写写文章，偶尔看到一些精彩的东西会做点记录，但是会经常乱放，要用到时找起来麻烦，有时会忘记放在哪了，所以想着搭建一个博客来记录这些东西，现在大家使用Hexo比较多，因此该文章主要介绍如何搭建Hexo，以及搭建过程中出现的一些问题，最后列出一些常用的命令. http://www.cnblogs.com/visugar/p/6821777.html 常见问题：http://blog.csdn.net/nathan1987_/article/details/50322493 使用命令：http://www.jianshu.com/p/3a8dba06856a Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenweijieno1.github.io/androidBlog/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenweijieno1.github.io/androidBlog/tags/Hexo/"}]},{"title":"系统集成项目管理工程师知识点记录","slug":"系统集成项目管理工程师知识点记录","date":"2017-10-25T16:00:00.000Z","updated":"2017-11-10T08:02:09.090Z","comments":true,"path":"2017/10/26/系统集成项目管理工程师知识点记录/","link":"","permalink":"https://chenweijieno1.github.io/androidBlog/2017/10/26/系统集成项目管理工程师知识点记录/","excerpt":"1、请简要叙述合同索赔流程 在索赔事项发生后的28天以内，以书面的索赔通知书形式向甲公司提出索赔要求； 在索赔通知书发出后的28天内，向甲公司报送补偿经济拔失的索赔报告及有关资料； 甲公司给予答复，对于不同意的，可要求乙部门进一步补充索赔理由和证据； 甲公司在收到索赔报告的有关资料后28天未予答复，表示认同索赔； 如果索赔事件持续进行时，乙部门应当阶段性向甲公司发出索赔意向，在索赔 事件终了后28天内，向甲公司送交索赔的有关资料和最终索赔报告； 甲公司或乙部门不能接受索赔结果的，可进入仲裁或诉讼程序；","text":"1、请简要叙述合同索赔流程 在索赔事项发生后的28天以内，以书面的索赔通知书形式向甲公司提出索赔要求； 在索赔通知书发出后的28天内，向甲公司报送补偿经济拔失的索赔报告及有关资料； 甲公司给予答复，对于不同意的，可要求乙部门进一步补充索赔理由和证据； 甲公司在收到索赔报告的有关资料后28天未予答复，表示认同索赔； 如果索赔事件持续进行时，乙部门应当阶段性向甲公司发出索赔意向，在索赔 事件终了后28天内，向甲公司送交索赔的有关资料和最终索赔报告； 甲公司或乙部门不能接受索赔结果的，可进入仲裁或诉讼程序； 总结来说，就如下流程：提出索赔要求-&gt;报送索赔资料-&gt;监理工程师答复-&gt;监理工程师逾期答复后果-&gt;持续索赔-&gt;仲裁与诉讼 注意点：双方直接签证补充协议的做法是不正确的。在政府釆购法中明确要求追加项目不得超过原合总金额的10% 2、简述范围变更控制的基本流程 编写范围说明书，进行范围确认，建立基线。 需求变更以书面的规定格式提出，提交给CCB。 CCB对变更申请进行论证、评估，评估对项目的进度、成本、质量等影响大小。 需求变更以书面的方式获得通过，并修改进度计划、成本计划等，未获通过的给出原因。 分派给项目组进行变更的实施。并通知所有相关干系人。 监督并控制变更的实施过程，处理产生的问题。 定期评估变更对项目绩效的影响，作为历史数据归入组织过程资产，有利于以后的评估准确。 注意：对范围变更进行控制是，要以工作分解结构、项目进展报告、变更请求和范围管理计划为依据。进行范围变更控制必须经过范围变更控制系统。 根据项目范围变更的流程，首先要提出项目变更请求，然后由项目利益相关人根据变更对项目影响（时间、成本等）进行决策变更，决定是否接受变更。如果不接受变更，则反馈给变更请求人，并说明不接受的原因。如果接受变更，则需要按照变更的流程，更新相应的计划和文档，实施范围变更。最后应对变更进行评审。 成本变更控制系统公司一种项目成本控制的程序性方法，主要通过建立项目成本变更控制体系对项目成本进行控制。该系统主要包括3个部分，分别是成本变更申请、批准成本变更申请和变更项目成本预算。 3、项目可行性研究的主要步骤 初步可行性研究 详细可行性研究 项目综合论证 项目可行性评估 项目可行性研究报告编写、提交和获得批准 4、关键路径分析和总时差、自由时差计算详细知识请参考：http://blog.csdn.net/moshengtan/article/details/13001751 如何计算ES,EF,LS,LF？前推法来计算最早时间 某一活动的最早开始时间（ES）=指向它的所有紧前活动的最早结束时间的最大值。 某一活动的最早结束时间（EF）=ES+T（作业时间） 逆推法来计算最迟时间 某一活动的最迟结束时间（LF）=指向它的所有紧后活动的最迟开始时间的最小值。 某一活动的最迟开始时间（LS）=LF-T（作业时间） 总时差与自由时差的区别？总时差是指在不延误项目完成日期或违反进度因素的前提下，某活动可以推迟的时间。 总时差=LS-ES=LF-EF自由时差是指在不影响紧后活动最早开始的情况下，当前活动可以推迟的时间。 自由时差=(后一活动)ES-(前一活动的)EF 所以总时差影响总工期，自由时差影响紧后活动。 计算关键路径的步骤： 用有方向的线段标出各结点的紧前活动和紧后活动的关系，使之成为一个有方向的网络图（PDM） 用正推和逆推法计算出各个活动的ES,LS,EF,LF，并计算出各个活动的自由时差。找出所有总时差为零或为负的活动，就是关键活动。 关键路径上的活动持续时间决定了项目的工期，总和就是项目工期。 5、信息系统工程监理活动的主要内容括“四控、三管、一协调”：四控：进度控制、质量控制、成本控制、变更控制三管：合同管理、安全管理、文档管理一协调：沟通与协调业主、承建方、设备和材料供应商之间的关系 6、信息系统集成项目的验收工作步骤系统测试 -&gt; 系统的试运行 -&gt; 系统的文档验收 -&gt; 项目的最终验收报告 7、招标文件招标文件应当包括招标项目的技术要求、对投标人资格审查的标准、投标报价要求和评标标准等所有实质性要求和条件，以及拟签订合同的主要条款。 8、项目范围管理活动编制范围管理计划、范围定义、创建工作分解结构、范围确认、范围控制 9、挣值管理法中的PV、EV、AC、SV、CV、SPI、CPIPV：计划值，在即定时间点前计划完成活动或WBS组件工作的预算成本。 记忆技巧：PLaned，计划，Value，数值，简写是PV AC：实际成本，在即定时间段内实比分完成工作发生的实际总成本。 记忆技巧：Actual，实际的，cost，成本，简写是AC EV：挣值，在即定时间段内实际完工工作的预算成本。 记忆技巧：Earn，挣，Value，数值，简写的EV 以下以公式中，以S开头的缩写，都是表示进度的，schedule。以C开头的缩写，都是表示成本的，cost。而且有一个规律，计算公式都是EV开头；偏差是用减法，即然是减法，那么肯定也是跟0比较；指数是用除法，那么也肯定是跟1比较。 进度偏差SV＝EV－PV，即然是进度方面的偏差，计算的肯定是进度方面的内容，那么上面两个参数PV、AC那个是跟进度有关系呢？肯定是PV计划值了，所以公式SV＝EV－PV的记忆就出来了。SV&gt;0，进度超前，SV&lt;0，进度落后。 成本偏差CV＝EV－AC，同上道理，成本方面的偏差，计算的也肯定是成本方面的内容，那么上面两个参数PV、AC那个是跟成本有关系的呢？肯定是AC实际成本了。所以公式CV＝EV－AC的记忆也出来了。CV&gt;0，成本节约，CV&lt;0，成本超支。 进度绩效指数SPI＝EV/PV，也好理解了，S开头的缩写，肯定是关于进度方面指数了，公式以EV作为开头的，SPI＝1，进度与计划相符，SPI&gt;1，进度超前，SPI&lt;1，进度落后。 成本绩效指数CPI＝EV/AC，C开头的缩写，关于成本方面指数，公式以EV开头，CPI＝1，资金使用效率一般；CPI&gt;1成本节约，资金使用效率高；CPI&lt;1，成本超支，资金使用效率低。 10、项目成本管理的过程 制定成本管理计划、成本估算、成本预算、成本控制 11、质量的定义 国际标准化组织： 反应实体满足主体明确和隐含需求的能力的特性总和； 国家标准：一组固有特性满足要求的程度 从用户角度：质量是对一个产品（包括相关的服务）满足程度的度量，是产品或服务的生命 12、项目人力资源管理的过程 1、编制人力资源计划 2、组建项目团队 3、建设项目团队 4、管理项目团队 13、项目整体管理的主要过程项目整体管理师项目管理中一项综合性盒全局性的管理工作。项目整体管理知识域包括保证项目各要素相互协调所需要的各个过程。具体地讲，项目整体管理知识域包括标识、定义、结合、统一和协调项目管理过程组中的不同过程和活动所需要的过程和活动。项目整体管理应确保项目所有的组成要素在正确的时间结合在一起，以成功完成项目。 项目整体管理与其他的项目单项管理（如项目进度管理、项目成本管理等）相比，具有综合性、全局性和系统性的特点。 项目管理中整体管理的过程包括制定项目章程、制定项目范围说明书（初步）、制定项目管理计划、指导和管理项目执行、监督和控制项目工作、整体变更控制、项目收尾。 14、项目计划过程项目规划—范围定义—活动定义—活动历时估算项目范围管理包括的过程依序排列为范围计划制定（或称范围规划）、范围定义、创建工作分解结构、范围核实、范围变更控制。 项目时间管理包括的过程排列为活动定义、活动排序、活动资源估算、活动历时估算、制定进度计划、进度计划控制。 一般情况下，应先确定项目的范围，然后再此基础上再对项目的时间进行管理。 15项目范围说明书包括项目和范围的目标、产品或服务的需求的特性、项目的边界、产品接受标准、项目约束条件、项目假设、最初的项目组织、最初定的风险、进度里程碑、费用估算的量级要求、项目配置管理的需求已批准的需求。 16 项目范围管理计划是范围计划编制过程的一个输出，规定了如何定义、检验、控制范围和创建与定义WBS，指导项目管理团队应如何管理项目的范围。 WBS是组织管理工作的主要依据，是项目管理工作的基础。这些项目管理工作包括定义工作范围、定义项目组织、设定项目产品的质量和规格、估算和控制费用以及估算时间周期和安排进度，因此，这些项目管理工作也是创建WBS的目标。WBS分解越准确，对进度和成本的估算也就越准确，越能促进明确分工。同时，WBS和WBS字典构成了项目的范围基线。 WBS具有以下4个用途： 1、WBS是一个描述思路的规划和设计工具，能够帮助项目经理和项目团队确定和有效地管理项目的工作。 2、WBS是一个清晰地表示各项目工作之间的相互联系的结构设计工具。 3、WBS是一个展现项目全貌，并且详细说明了为完成项目所必须完成的各项工作的计划工具。 4、WBS定义的里程碑事件，可以向高级管理层和客户报告项目的完成情况，是项目状况的报告工具 17 项目进度网络图项目进度控制的过程大致为活动定义、活动排序、活动资源估算、活动历时估算、进度计划的制定、进度控制在项目管理中，首先通过对项目活动进行排序，得到项目进度网络图。再根据项目进度网络图找到项目的关键路径，从而制定项目的进度计划。由此可见，项目进度网络图是活动排序的结果和进度计划编制的输入。 18缩短项目进度的技术主要如下：1、变更项目范围：主要是指缩小项目的范围2、赶工：是一种通过分配很多的资源，达到以成本的最低增加和进度的最大限度压缩的目的，它不改变活动之间的顺序。3、快速追踪：也叫快速跟进，是指并行或重叠执行原来计划串行执行的活动，会改变工作网络图原来的顺序 19一般来说，项目活动间存在以下4个依赖关系。1、结束—开始（FS型）：某活动必须结束，另一活动才能开始2、结束—结束（FF型）：某活动结束前，另一活动必须结束3、开始—结束（SF型）：某活动结束前另一活动必须开始4、开始—开始（SS型）：某活动必须在另一活动开始前开始 在某个信息系统项目中，存在新老系统切换问题。在设置项目计划网络图时，新系统上线和老系统下线之间应设置成开始-结束的关系 20 活动的期望时间活动的期望时间=（最乐观时间+4*最可能时间+最悲观时间）/6 21管理项目团队是项目人力资源管理的内容之一，其工具及技术包括如下内容：观察和对话、项目绩效评估、冲突管理、问题日志 22《中华人民共和国合同法》第五十二条规定，有下列情形之一的，合同无效：1、一方以欺诈、胁迫的手段订立合同，损害国家利益的；2、恶意串通，损害国家、集体或者第三人利益的3、以合法形式掩盖非法目的的；4、损害社会公共利益的5、违反法律、行政法规的强制性规定的 23 应对风险的3项基本原则规避、接受、减轻 在项目风险管理的基本流程中，包括以下6项主要活动编制风险管理计划：确定项目中风险管理活动的步骤识别风险：确定项目中可能存在的风险风险定性分析：通过对风险的发生概率和潜在影响排定风险的优先级，作为后续分析的准备风险定量分析：量化风险分析对项目目标的影响编制风险应对策略：制定相应的策略，减轻风险对项目目标的影响风险跟踪和监控：跟踪并监控识别出的风险，执行风险应对策略，并评估其再整个项目生命周期中的效果风险规避措施是编制风险应对计划的一项输出，不属于风险管理基本流程中的活动。","categories":[{"name":"系统集成项目管理工程师","slug":"系统集成项目管理工程师","permalink":"https://chenweijieno1.github.io/androidBlog/categories/系统集成项目管理工程师/"}],"tags":[{"name":"系统集成项目管理工程师","slug":"系统集成项目管理工程师","permalink":"https://chenweijieno1.github.io/androidBlog/tags/系统集成项目管理工程师/"}]}]}